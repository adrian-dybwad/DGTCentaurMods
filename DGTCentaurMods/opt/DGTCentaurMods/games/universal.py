# Universal Game Handler
#
# This file is part of the DGTCentaur Mods open source software
# ( https://github.com/EdNekebno/DGTCentaur )
#
# DGTCentaur Mods is free software: you can redistribute
# it and/or modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation, either
# version 3 of the License, or (at your option) any later version.
#
# DGTCentaur Mods is distributed in the hope that it will
# be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this file.  If not, see
#
# https://github.com/EdNekebno/DGTCentaur/blob/master/LICENSE.md
#
# This and any other notices must remain intact and unaltered in any
# distribution, modification, variant, or derivative of this software.

from DGTCentaurMods.board.logging import log
from DGTCentaurMods.games.millennium import Millennium
from DGTCentaurMods.games.pegasus import Pegasus
from DGTCentaurMods.games.chessnut import Chessnut
from DGTCentaurMods.games.manager import GameManager


class Universal:
    """Universal game handler that supports multiple protocols (Millennium, Pegasus, Chessnut).
    
    This class can operate in two modes:
    1. Known client type (BLE): Only creates the specific emulator for that protocol
    2. Unknown client type (RFCOMM): Creates all RFCOMM-capable emulators and auto-detects
    
    In relay mode (compare_mode=True), emulator responses are buffered for comparison
    with shadow host responses instead of being sent directly to the client.
    """
    
    # Client type constants
    CLIENT_UNKNOWN = "unknown"
    CLIENT_MILLENNIUM = "millennium"
    CLIENT_PEGASUS = "pegasus"
    CLIENT_CHESSNUT = "chessnut"
    
    def __init__(self, sendMessage_callback=None, client_type=None, compare_mode=False):
        """Initialize the Universal handler.
        
        Args:
            sendMessage_callback: Callback function(data) for sending messages to client
            client_type: Hint about client type from BLE service UUID:
                        - CLIENT_MILLENNIUM: Millennium ChessLink
                        - CLIENT_PEGASUS: Nordic UART (Pegasus)
                        - CLIENT_CHESSNUT: Chessnut Air
                        - CLIENT_UNKNOWN or None: Auto-detect from incoming data (RFCOMM)
            compare_mode: If True, buffer emulator responses for comparison with
                         shadow host instead of sending directly. Used in relay mode.
        """
        self._sendMessage = sendMessage_callback
        self.compare_mode = compare_mode
        self._pending_response = None
        
        # Store the hint but don't trust it - always verify from data
        self._client_type_hint = client_type
        self.client_type = self.CLIENT_UNKNOWN
        
        # Protocol detection flags - only set True after data confirms protocol
        self.is_millennium = False
        self.is_pegasus = False
        self.is_chessnut = False
        
        # Game manager shared by all emulators
        self.manager = GameManager()
        
        # Emulator instances - always create all emulators for auto-detection
        # The hint from BLE characteristic is unreliable as apps may connect to any service
        self._millennium = None
        self._pegasus = None
        self._chessnut = None
        
        # Always create all emulators for auto-detection from actual data
        # The client_type hint from BLE service UUID is unreliable
        log.info(f"[Universal] Creating emulators for auto-detection (hint: {client_type or 'none'})")
        
        # Create Millennium emulator
        self._millennium = Millennium(
            sendMessage_callback=self._handle_emulator_response,
            manager=self.manager
        )
        log.info("[Universal] Created Millennium emulator")
        
        # Create Pegasus emulator
        self._pegasus = Pegasus(
            sendMessage_callback=self._handle_emulator_response,
            manager=self.manager
        )
        log.info("[Universal] Created Pegasus emulator")
        
        # Create Chessnut emulator
        self._chessnut = Chessnut(
            sendMessage_callback=self._handle_emulator_response,
            manager=self.manager
        )
        log.info("[Universal] Created Chessnut emulator")
        
        self.subscribe_manager()
    
    def _handle_emulator_response(self, data):
        """Handle response generated by an emulator.
        
        In compare_mode, buffers the response for later comparison with shadow host.
        Otherwise, sends directly to the client.
        
        Args:
            data: Response data bytes from emulator
        """
        if self.compare_mode:
            self._pending_response = bytes(data) if data else None
            log.debug(f"[Universal] Emulator response buffered ({len(data) if data else 0} bytes)")
        else:
            if self._sendMessage:
                self._sendMessage(data)
    
    def get_pending_response(self):
        """Get and clear the pending emulator response.
        
        Used in compare_mode to retrieve the buffered response for comparison.
        
        Returns:
            The buffered response bytes, or None if no response pending
        """
        response = self._pending_response
        self._pending_response = None
        return response
    
    def compare_with_shadow(self, shadow_response):
        """Compare shadow host response with emulator response.
        
        Args:
            shadow_response: Response bytes from shadow host
            
        Returns:
            Tuple (match, emulator_response) where:
            - match: True if responses match, False if different, None if no emulator response
            - emulator_response: The emulator's response bytes (for logging)
        """
        emulator_response = self.get_pending_response()
        
        if emulator_response is None:
            log.debug("[Universal] No emulator response to compare (emulator may not have generated one)")
            return (None, None)
        
        shadow_bytes = bytes(shadow_response) if shadow_response else b''
        match = emulator_response == shadow_bytes
        
        if not match:
            log.warning("[Universal] Response MISMATCH between emulator and shadow host:")
            log.warning(f"  Shadow host: {shadow_bytes.hex() if shadow_bytes else '(empty)'}")
            log.warning(f"  Emulator:    {emulator_response.hex() if emulator_response else '(empty)'}")
        else:
            log.debug(f"[Universal] Response match: {shadow_bytes.hex()}")
        
        return (match, emulator_response)
    
    def _manager_event_callback(self, event, piece_event=None, field=None, time_in_seconds=None):
        """Handle game events from the manager.
        
        Routes events to the active emulator based on detected protocol.
        Before protocol is confirmed, forwards to ALL emulators so that
        whichever one is active will respond correctly.
        
        Args:
            event: Event constant (EVENT_NEW_GAME, EVENT_WHITE_TURN, etc.)
            piece_event: Piece event type
            field: Chess field index
            time_in_seconds: Time since game start
        """
        try:
            log.debug(f"[Universal] _manager_event_callback: {event} piece_event={piece_event}, field={field}")
            log.debug(f"[Universal] Flags: is_millennium={self.is_millennium}, is_pegasus={self.is_pegasus}, is_chessnut={self.is_chessnut}")
            log.debug(f"[Universal] Emulators: _millennium={self._millennium is not None}, _pegasus={self._pegasus is not None}, _chessnut={self._chessnut is not None}")
            
            # If protocol is confirmed, only forward to the active emulator
            if self.is_millennium and self._millennium and hasattr(self._millennium, 'handle_manager_event'):
                log.debug("[Universal] Routing event to Millennium")
                self._millennium.handle_manager_event(event, piece_event, field, time_in_seconds)
            elif self.is_pegasus and self._pegasus and hasattr(self._pegasus, 'handle_manager_event'):
                log.debug("[Universal] Routing event to Pegasus")
                self._pegasus.handle_manager_event(event, piece_event, field, time_in_seconds)
            elif self.is_chessnut and self._chessnut and hasattr(self._chessnut, 'handle_manager_event'):
                log.debug("[Universal] Routing event to Chessnut")
                self._chessnut.handle_manager_event(event, piece_event, field, time_in_seconds)
            else:
                # Protocol not yet confirmed - forward to ALL emulators
                # Each emulator will only act if it has reporting enabled
                log.debug("[Universal] Protocol not confirmed, forwarding event to all emulators")
                if self._millennium and hasattr(self._millennium, 'handle_manager_event'):
                    self._millennium.handle_manager_event(event, piece_event, field, time_in_seconds)
                if self._pegasus and hasattr(self._pegasus, 'handle_manager_event'):
                    self._pegasus.handle_manager_event(event, piece_event, field, time_in_seconds)
                if self._chessnut and hasattr(self._chessnut, 'handle_manager_event'):
                    self._chessnut.handle_manager_event(event, piece_event, field, time_in_seconds)
        except Exception as e:
            log.error(f"[Universal] Error in _manager_event_callback: {e}")
            import traceback
            traceback.print_exc()
    
    def _manager_move_callback(self, move):
        """Handle moves from the manager.
        
        Before protocol is confirmed, forwards to ALL emulators.
        
        Args:
            move: Chess move object
        """
        try:
            log.debug(f"[Universal] _manager_move_callback: {move}")
            
            if self.is_millennium and self._millennium and hasattr(self._millennium, 'handle_manager_move'):
                self._millennium.handle_manager_move(move)
            elif self.is_pegasus and self._pegasus and hasattr(self._pegasus, 'handle_manager_move'):
                self._pegasus.handle_manager_move(move)
            elif self.is_chessnut and self._chessnut and hasattr(self._chessnut, 'handle_manager_move'):
                self._chessnut.handle_manager_move(move)
            else:
                # Protocol not yet confirmed - forward to ALL emulators
                log.debug("[Universal] Protocol not confirmed, forwarding move to all emulators")
                if self._millennium and hasattr(self._millennium, 'handle_manager_move'):
                    self._millennium.handle_manager_move(move)
                if self._pegasus and hasattr(self._pegasus, 'handle_manager_move'):
                    self._pegasus.handle_manager_move(move)
                if self._chessnut and hasattr(self._chessnut, 'handle_manager_move'):
                    self._chessnut.handle_manager_move(move)
        except Exception as e:
            log.error(f"[Universal] Error in _manager_move_callback: {e}")
            import traceback
            traceback.print_exc()
    
    def _manager_key_callback(self, key):
        """Handle key presses from the manager.
        
        Args:
            key: Key that was pressed (board.Key enum value)
        """
        try:
            log.info(f"[Universal] _manager_key_callback: {key}")
            
            if self.is_millennium and self._millennium and hasattr(self._millennium, 'handle_manager_key'):
                self._millennium.handle_manager_key(key)
            elif self.is_pegasus and self._pegasus and hasattr(self._pegasus, 'handle_manager_key'):
                self._pegasus.handle_manager_key(key)
            elif self.is_chessnut and self._chessnut and hasattr(self._chessnut, 'handle_manager_key'):
                self._chessnut.handle_manager_key(key)
        except Exception as e:
            log.error(f"[Universal] Error in _manager_key_callback: {e}")
            import traceback
            traceback.print_exc()
    
    def _manager_takeback_callback(self):
        """Handle takeback requests from the manager."""
        try:
            log.info("[Universal] _manager_takeback_callback")
            
            if self.is_millennium and self._millennium and hasattr(self._millennium, 'handle_manager_takeback'):
                self._millennium.handle_manager_takeback()
            elif self.is_pegasus and self._pegasus and hasattr(self._pegasus, 'handle_manager_takeback'):
                self._pegasus.handle_manager_takeback()
            elif self.is_chessnut and self._chessnut and hasattr(self._chessnut, 'handle_manager_takeback'):
                self._chessnut.handle_manager_takeback()
        except Exception as e:
            log.error(f"[Universal] Error in _manager_takeback_callback: {e}")
            import traceback
            traceback.print_exc()

    def receive_data(self, byte_value):
        """Receive one byte of data and route to appropriate emulator.
        
        Auto-detects protocol from actual data. If a client_type hint was provided
        at construction (from BLE service UUID), that protocol is tried first.
        Once a protocol is detected, unused emulators are freed to save memory.
        
        Args:
            byte_value: Raw byte value from wire
            
        Returns:
            True if byte was successfully parsed, False otherwise
        """
        # If already detected, route directly to that emulator
        if self.is_millennium and self._millennium:
            return self._millennium.parse_byte(byte_value)
        elif self.is_pegasus and self._pegasus:
            return self._pegasus.parse_byte(byte_value)
        elif self.is_chessnut and self._chessnut:
            return self._chessnut.parse_byte(byte_value)
        
        # Auto-detect: try emulators in priority order based on hint
        # Build priority order - hinted protocol first, then others
        emulators_to_try = []
        
        if self._client_type_hint == self.CLIENT_MILLENNIUM:
            emulators_to_try = [
                (self._millennium, "Millennium", self.CLIENT_MILLENNIUM),
                (self._pegasus, "Pegasus", self.CLIENT_PEGASUS),
                (self._chessnut, "Chessnut", self.CLIENT_CHESSNUT),
            ]
        elif self._client_type_hint == self.CLIENT_PEGASUS:
            emulators_to_try = [
                (self._pegasus, "Pegasus", self.CLIENT_PEGASUS),
                (self._millennium, "Millennium", self.CLIENT_MILLENNIUM),
                (self._chessnut, "Chessnut", self.CLIENT_CHESSNUT),
            ]
        elif self._client_type_hint == self.CLIENT_CHESSNUT:
            emulators_to_try = [
                (self._chessnut, "Chessnut", self.CLIENT_CHESSNUT),
                (self._millennium, "Millennium", self.CLIENT_MILLENNIUM),
                (self._pegasus, "Pegasus", self.CLIENT_PEGASUS),
            ]
        else:
            # No hint - default order
            emulators_to_try = [
                (self._millennium, "Millennium", self.CLIENT_MILLENNIUM),
                (self._pegasus, "Pegasus", self.CLIENT_PEGASUS),
                (self._chessnut, "Chessnut", self.CLIENT_CHESSNUT),
            ]
        
        for emulator, name, client_type in emulators_to_try:
            if emulator and emulator.parse_byte(byte_value):
                hint_match = " (matches hint)" if self._client_type_hint == client_type else ""
                hint_mismatch = f" (hint was {self._client_type_hint})" if self._client_type_hint and self._client_type_hint != client_type else ""
                log.info(f"[Universal] {name} protocol detected via auto-detection{hint_match}{hint_mismatch}")
                
                self.client_type = client_type
                
                # Set the appropriate flag and free unused emulators
                if client_type == self.CLIENT_MILLENNIUM:
                    self.is_millennium = True
                    self._pegasus = None
                    self._chessnut = None
                elif client_type == self.CLIENT_PEGASUS:
                    self.is_pegasus = True
                    self._millennium = None
                    self._chessnut = None
                elif client_type == self.CLIENT_CHESSNUT:
                    self.is_chessnut = True
                    self._millennium = None
                    self._pegasus = None
                
                return True
        
        return False

    def reset_parser(self):
        """Reset the packet parser state for all active emulators.
        
        Clears any accumulated buffer and resets parser to initial state.
        Useful when starting a new communication session or recovering from errors.
        """
        if self._millennium:
            self._millennium.reset_parser()
        if self._pegasus:
            self._pegasus.reset()
        if self._chessnut:
            self._chessnut.reset()

    def subscribe_manager(self):
        """Subscribe to the game manager with callbacks."""
        try:
            log.info("[Universal] Subscribing to game manager")
            self.manager.subscribe_game(
                self._manager_event_callback,
                self._manager_move_callback,
                self._manager_key_callback,
                self._manager_takeback_callback
            )
            log.info("[Universal] Successfully subscribed to game manager")
        except Exception as e:
            log.error(f"[Universal] Failed to subscribe to game manager: {e}")
            import traceback
            traceback.print_exc()
