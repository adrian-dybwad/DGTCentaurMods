{% extends "base.html" %}

{% block mainpage %}

<script type="text/javascript" src="{{ url_for('static', filename='stockfish/stockfish.js') }}"></script>
<script type="text/javascript" src="{{ url_for('static', filename='js/domarrow.js') }}"></script>
<script type="text/javascript" src="{{ url_for('static', filename='js/chess.js') }}"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.4/dist/Chart.min.js"></script>
<script src="{{ url_for('static', filename='js/analysis.js') }}"></script>

<style>
    /* Arrow connections for best move visualization */
    connection .line .arrow {
      top: -5px;
      height: 0px;
      width: 0px;
      position: absolute;
      border-bottom: 6px solid transparent;
      border-top: 6px solid transparent;
      background-clip: border-box;
    }
    connection .line .arrow-fw {
      border-right: 12px solid black;
    }
    connection .line .arrow-bw {
      left: 100%;
      border-left: 12px solid black;
      transform: translateX(-12px);
    }
    connection .line .text {
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translate(-50%, -100%);
    }
    connection .line {
      position: absolute;
      height: 2px;
      background-color: black;
    }
    
    /* Responsive analysis layout */
    .analysis-container {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
    }
    
    .analysis-board {
        flex: 1 1 400px;
        min-width: 300px;
    }
    
    .analysis-sidebar {
        flex: 1 1 300px;
        min-width: 280px;
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }
    
    .analysis-moves {
        max-height: 300px;
        overflow-y: auto;
    }
    
    .analysis-pgn textarea {
        width: 100%;
        min-height: 150px;
    }
    
    @media (max-width: 768px) {
        .analysis-board, .analysis-sidebar {
            flex: 1 1 100%;
        }
    }
    
    /* Move table styling */
    .move-table {
        width: 100%;
        border-collapse: collapse;
    }
    .move-table td {
        padding: 0.25rem 0.5rem;
        cursor: pointer;
    }
    .move-table td:hover {
        background-color: var(--color-bg-hover, #e8e8e8);
    }
    .move-table .current-move {
        background-color: var(--color-accent-light, #f0d0f0);
    }
    .move-table .move-number {
        font-weight: bold;
        width: 40px;
        cursor: default;
    }
    .move-table .move-number:hover {
        background-color: transparent;
    }
    .move-table .move-eval {
        font-size: 0.75rem;
        color: var(--color-text-muted, #888);
        margin-left: 0.5rem;
    }
</style>

<div class="analysis-container">
    <div class="analysis-board">
        {% include 'chessboard_component.html' %}
    </div>
    
    <div class="analysis-sidebar">
        <!-- Analysis component (chart, eval bar, navigation) -->
        <div class="box">
            {% include 'analysis_component.html' %}
        </div>
        
        <!-- Move table -->
        <div class="box">
            <h4 class="title is-6" style="margin-bottom: 0.5rem;">Moves</h4>
            <div id="moveholder" class="analysis-moves"></div>
        </div>
        
        <!-- PGN textarea -->
        <div class="box analysis-pgn">
            <h4 class="title is-6" style="margin-bottom: 0.5rem;">PGN</h4>
            <textarea id="gamepgn" class="textarea" placeholder="" rows="6" readonly></textarea>
        </div>
    </div>
</div>

<script>
    const gameid = {{ gameid }};
    
    // Initialize analysis engine in static mode for game review
    window.addEventListener('load', function() {
        analysisEngine.init({
            mode: 'static',
            containerId: 'analysis',
            stockfishPath: "{{ url_for('static', filename='stockfish/stockfish.js') }}",
            onPositionChange: function(fen, moveNumber) {
                // Update board position
                if (typeof board1 !== 'undefined' && fen) {
                    board1.position(fen);
                }
                // Update move table highlighting
                buildMovesTable();
                // Draw best move arrow (will be updated when analysis completes)
                $('connection').remove();
            }
        });
        
        // Load the game PGN
        loadGamePgn();
    });
    
    // Listen for position changes to draw arrows and update table
    window.addEventListener('analysisPositionChange', function(event) {
        buildMovesTable();
    });
    
    function loadGamePgn() {
        fetch('/getpgn/' + gameid)
            .then(response => {
                if (!response.ok) throw new Error('Failed to load PGN');
                return response.text();
            })
            .then(pgn => {
                document.getElementById('gamepgn').value = pgn;
                
                if (analysisEngine.loadPgn(pgn)) {
                    // Start at the latest position like the old analysis page.
                    // This ensures the eval display updates once replay completes.
                    analysisEngine.goToMove(analysisEngine.getTotalMoves());
                    buildMovesTable();
                } else {
                    document.getElementById('gamepgn').value = 'Error: Could not parse PGN\n\n' + pgn;
                }
            })
            .catch(err => {
                console.error('Error loading PGN:', err);
                document.getElementById('gamepgn').value = 'Error: Could not load game';
            });
    }
    
    function buildMovesTable() {
        const movePos = analysisEngine.getMovePos();
        const totalMoves = analysisEngine.getTotalMoves();
        const evalHistory = analysisEngine.getEvalHistory();
        
        // Get moves from PGN textarea
        const pgnText = document.getElementById('gamepgn').value;
        const tempChess = new Chess();
        if (!tempChess.load_pgn(pgnText)) {
            return;
        }
        const moves = tempChess.history();
        
        if (moves.length === 0) {
            document.getElementById('moveholder').innerHTML = '<p class="has-text-grey">No moves</p>';
            return;
        }
        
        // Build table with moves centered around current position
        const centerMove = movePos > 0 ? movePos - 1 : 0;
        const startPly = Math.max(0, Math.floor(centerMove / 2) * 2 - 8);
        const endPly = Math.min(moves.length, startPly + 20);
        
        let html = '<table class="move-table">';
        
        for (let ply = startPly; ply < endPly; ply += 2) {
            const moveNum = Math.floor(ply / 2) + 1;
            html += '<tr>';
            
            // Move number
            html += `<td class="move-number">${moveNum}.</td>`;
            
            // White's move
            const whiteEval = evalHistory.find(e => e.moveNum === ply + 1);
            const whiteEvalText = whiteEval ? `<span class="move-eval">${(whiteEval.eval / 100).toFixed(1)}</span>` : '';
            const whiteCurrent = (ply + 1) === movePos ? 'current-move' : '';
            html += `<td class="${whiteCurrent}" onclick="analysisEngine.goToMove(${ply + 1})">${moves[ply]}${whiteEvalText}</td>`;
            
            // Black's move
            if (ply + 1 < moves.length) {
                const blackEval = evalHistory.find(e => e.moveNum === ply + 2);
                const blackEvalText = blackEval ? `<span class="move-eval">${(blackEval.eval / 100).toFixed(1)}</span>` : '';
                const blackCurrent = (ply + 2) === movePos ? 'current-move' : '';
                html += `<td class="${blackCurrent}" onclick="analysisEngine.goToMove(${ply + 2})">${moves[ply + 1]}${blackEvalText}</td>`;
            } else {
                html += '<td></td>';
            }
            
            html += '</tr>';
        }
        
        html += '</table>';
        document.getElementById('moveholder').innerHTML = html;
    }
    
    // Draw best move arrow when analysis completes
    // This listens for the eval bar update as a proxy for analysis completion
    const originalUpdateEvalBar = window.updateEvalBar;
    // Note: Arrow drawing handled by domarrow.js when best move is found
</script>

{% endblock %}
