{% extends "base.html" %}

{% block mainpage %}

<script type="text/javascript" src="{{ url_for('static', filename='stockfish/stockfish.js') }}"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.4/dist/Chart.min.js"></script>

<div class="columns">
  <div class="column is-8">
    {% include "liveboard.html" %}
  </div>
  <div class="column is-4">
    <div class="box">
      <h3 class="title is-5" style="color: var(--color-accent-secondary);">Current Game</h3>
      <div id="current-game-info">
        <p class="has-text-grey">Waiting for game...</p>
      </div>
    </div>
    
    <div class="box" style="margin-top: 1rem;">
      <h3 class="title is-5" style="color: var(--color-accent-secondary);">Analysis</h3>
      <div id="live-analysis">
        <p class="has-text-grey">Waiting for position...</p>
      </div>
      <progress id="live-eval-bar" class="progress" value="50" max="100" style="margin-top: 0.5rem; height: 0.5rem;"></progress>
      <div style="height: 120px; margin-top: 0.5rem;">
        <canvas id="eval-history-chart"></canvas>
      </div>
      <a href="/pgn" class="button is-primary is-small" style="margin-top: 1rem;">View All Games</a>
    </div>
    
    <div class="box" style="margin-top: 1rem;">
      <h3 class="title is-5" style="color: var(--color-accent-secondary);">Current PGN</h3>
      <textarea id="lastpgn" class="textarea" placeholder="PGN will appear here during play..." rows="8" readonly></textarea>
    </div>
  </div>
</div>

<script>
  // Stockfish analysis for live game
  let liveStockfish = null;
  let currentAnalysisFen = null;
  let lastEvalScore = 0;
  let bestMoveUci = '';
  let lastMoveNumber = 0;
  
  // Evaluation history chart
  let evalHistoryChart = null;
  let evalHistory = [];  // Array of {moveNum, eval} for chart
  
  function initEvalHistoryChart() {
    const ctx = document.getElementById('eval-history-chart');
    if (!ctx) return;
    
    evalHistoryChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [{
          label: 'Eval',
          data: [],
          fill: true,
          borderColor: 'rgb(150, 150, 150)',
          borderWidth: 1,
          lineTension: 0.4,
          backgroundColor: 'rgba(150, 150, 150, 0.3)',
          pointRadius: 3,
          pointBackgroundColor: 'rgba(255, 255, 255, 1)'
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        title: { display: false },
        legend: { display: false },
        layout: { padding: { bottom: 0 } },
        scales: {
          yAxes: [{
            display: true,
            ticks: {
              min: -500,
              max: 500,
              stepSize: 250,
              callback: function(value) {
                return (value / 100).toFixed(0);
              }
            },
            gridLines: { display: true, color: 'rgba(200,200,200,0.3)' }
          }],
          xAxes: [{
            display: false,
            gridLines: { display: false }
          }]
        },
        tooltips: {
          callbacks: {
            label: function(tooltipItem) {
              return (tooltipItem.yLabel / 100).toFixed(2);
            }
          }
        }
      }
    });
  }
  
  function resetEvalHistory() {
    evalHistory = [];
    if (evalHistoryChart) {
      evalHistoryChart.data.labels = [];
      evalHistoryChart.data.datasets[0].data = [];
      evalHistoryChart.update();
    }
  }
  
  function addEvalToHistory(moveNum, evalCp) {
    // Clamp eval for display
    const clampedEval = Math.max(-500, Math.min(500, evalCp));
    
    // Check if we already have this move number (update it)
    const existingIndex = evalHistory.findIndex(e => e.moveNum === moveNum);
    if (existingIndex >= 0) {
      evalHistory[existingIndex].eval = clampedEval;
    } else {
      evalHistory.push({ moveNum, eval: clampedEval });
      // Sort by move number
      evalHistory.sort((a, b) => a.moveNum - b.moveNum);
    }
    
    // Update chart
    if (evalHistoryChart) {
      evalHistoryChart.data.labels = evalHistory.map(e => e.moveNum);
      evalHistoryChart.data.datasets[0].data = evalHistory.map(e => e.eval);
      evalHistoryChart.update();
    }
  }
  
  function initLiveStockfish() {
    if (liveStockfish) return;
    
    try {
      liveStockfish = new Worker("{{ url_for('static', filename='stockfish/stockfish.js') }}");
      
      liveStockfish.onmessage = function(event) {
        const line = event.data;
        
        // Parse evaluation from "info" lines
        if (line.indexOf("score cp") > 0) {
          const cpMatch = line.match(/score cp (-?\d+)/);
          if (cpMatch) {
            let cp = parseInt(cpMatch[1]);
            // Negate if it's black's turn (we want score from white's perspective)
            if (currentAnalysisFen && currentAnalysisFen.includes(' b ')) {
              cp = -cp;
            }
            lastEvalScore = cp;
            updateEvalBar(cp);
          }
        }
        
        // Parse mate score
        if (line.indexOf("score mate") > 0) {
          const mateMatch = line.match(/score mate (-?\d+)/);
          if (mateMatch) {
            let mateIn = parseInt(mateMatch[1]);
            if (currentAnalysisFen && currentAnalysisFen.includes(' b ')) {
              mateIn = -mateIn;
            }
            lastEvalScore = mateIn > 0 ? 10000 : -10000;
            updateEvalBar(lastEvalScore);
            updateAnalysisDisplay(null, mateIn);
          }
        }
        
        // Parse best move - this means analysis is complete for this position
        if (line.indexOf("bestmove ") === 0) {
          bestMoveUci = line.split(' ')[1];
          updateAnalysisDisplay(bestMoveUci, null);
          // Add final eval to history
          if (lastMoveNumber > 0) {
            addEvalToHistory(lastMoveNumber, lastEvalScore);
          }
        }
      };
      
      // Initialize engine
      liveStockfish.postMessage('uci');
    } catch (e) {
      console.error('Failed to initialize Stockfish:', e);
    }
  }
  
  function analyzePosition(fen, moveNumber) {
    if (!liveStockfish || !fen) return;
    
    currentAnalysisFen = fen;
    lastMoveNumber = moveNumber || 0;
    bestMoveUci = '';
    
    // Send position and start analysis
    liveStockfish.postMessage('position fen ' + fen);
    liveStockfish.postMessage('go depth 15');
  }
  
  function updateEvalBar(cp) {
    const bar = document.getElementById('live-eval-bar');
    if (!bar) return;
    
    // Clamp to +/- 10 pawns, then map to 0-100
    let clampedCp = Math.max(-1000, Math.min(1000, cp));
    let barValue = 50 - (clampedCp / 20); // +10 pawns = 0%, -10 pawns = 100%
    bar.value = barValue;
    
    // Color based on who's winning
    if (cp > 100) {
      bar.className = 'progress is-success';
    } else if (cp < -100) {
      bar.className = 'progress is-danger';
    } else {
      bar.className = 'progress is-warning';
    }
  }
  
  function updateAnalysisDisplay(bestMove, mateIn) {
    const container = document.getElementById('live-analysis');
    if (!container) return;
    
    let evalText = '';
    if (mateIn !== null) {
      evalText = mateIn > 0 ? `Mate in ${mateIn}` : `Mate in ${-mateIn} (for Black)`;
    } else {
      const pawns = (lastEvalScore / 100).toFixed(1);
      evalText = lastEvalScore >= 0 ? `+${pawns}` : `${pawns}`;
    }
    
    let moveText = bestMove ? `Best: <strong>${bestMove}</strong>` : 'Analyzing...';
    
    container.innerHTML = `
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span style="font-size: 1.5rem; font-weight: bold;">${evalText}</span>
        <span>${moveText}</span>
      </div>
    `;
  }
  
  // Update current game info from SSE game state updates
  function updateCurrentGameInfo(state) {
    const container = document.getElementById('current-game-info');
    if (!state || !state.fen) {
      container.innerHTML = '<p class="has-text-grey">Waiting for game...</p>';
      return;
    }
    
    const white = state.white || 'White';
    const black = state.black || 'Black';
    const turn = state.turn === 'w' ? 'White' : 'Black';
    const moveNum = state.move_number || 1;
    const result = state.result || '';
    const gameOver = state.game_over || false;
    
    // Detect new game (move number reset to 1 and we had moves before)
    if (moveNum === 1 && lastMoveNumber > 1) {
      resetEvalHistory();
    }
    
    let statusText = '';
    if (gameOver && result) {
      statusText = `<span class="tag is-info">${result}</span>`;
    } else {
      statusText = `<span class="tag is-light">Move ${moveNum} - ${turn} to play</span>`;
    }
    
    container.innerHTML = `
      <div style="padding: 0.5rem 0;">
        <div style="margin-bottom: 0.5rem;">
          <strong>${white}</strong> <span style="color: var(--color-text-muted);">(W)</span>
          vs
          <strong>${black}</strong> <span style="color: var(--color-text-muted);">(B)</span>
        </div>
        ${statusText}
      </div>
    `;
    
    // Trigger analysis on new position
    if (state.fen && state.fen !== currentAnalysisFen && !gameOver) {
      analyzePosition(state.fen, moveNum);
    }
  }
  
  // Listen for game state updates from SSE (dispatched by liveboard.html)
  window.addEventListener('gameStateUpdate', function(event) {
    updateCurrentGameInfo(event.detail);
  });
  
  // Initialize Stockfish and chart when page loads
  window.addEventListener('load', function() {
    initEvalHistoryChart();
    initLiveStockfish();
  });
  
  // Initial state - will be updated when SSE connects
  updateCurrentGameInfo(null);
</script>

{% endblock %}
